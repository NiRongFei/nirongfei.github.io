(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{544:function(t,n,s){"use strict";s.r(n);var e=s(2),a=Object(e.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[s("img",{attrs:{src:"https://camo.githubusercontent.com/8c32afe801835586c6ee59ef570fe2b322eadd6e/68747470733a2f2f79636b2d313235343236333432322e636f732e61702d7368616e676861692e6d7971636c6f75642e636f6d2f626c6f672f323031392d30362d30312d3033333932352e706e67",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"prototype"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prototype"}},[t._v("#")]),t._v(" prototype")]),t._v(" "),s("p",[t._v("首先来介绍下 "),s("code",[t._v("prototype")]),t._v(" 属性。这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" fun "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("prototype")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 "),s("code",[t._v("prototype")]),t._v(" 属性的。")]),t._v(" "),s("p",[t._v("当我们声明一个函数时，这个属性就被自动创建了。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("并且这个属性的值是一个对象（也就是原型），只有一个属性 "),s("code",[t._v("constructor")]),t._v("，"),s("code",[t._v("constructor")]),t._v(" 对应着构造函数，也就是 Foo。")]),t._v(" "),s("p",[s("code",[t._v("constructor")]),t._v(" 是一个公有且不可枚举的属性。一旦我们改变了函数的 "),s("code",[t._v("prototype")]),t._v(" ，那么新对象就没有这个属性了（当然可以通过原型链取到 "),s("code",[t._v("constructor")]),t._v("）。")]),t._v(" "),s("p",[t._v("那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：")]),t._v(" "),s("ul",[s("li",[t._v("让实例对象知道是什么函数构造了它；")]),t._v(" "),s("li",[t._v("如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展；")])]),t._v(" "),s("h2",{attrs:{id:"proto"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proto"}},[t._v("#")]),t._v(" "),s("strong",[t._v("proto")])]),t._v(" "),s("p",[t._v("这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 "),s("code",[t._v("[[prototype]]")]),t._v("，但是 "),s("code",[t._v("[[prototype]]")]),t._v(" 是内部属性，我们并不能访问到，所以使用 "),s("code",[t._v("__proto__")]),t._v(" 来访问。")]),t._v(" "),s("p",[t._v("因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 "),s("code",[t._v("__proto__")]),t._v(" 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。")]),t._v(" "),s("p",[t._v("当我们使用 "),s("code",[t._v("new")]),t._v(" 操作符时，生成的实例对象拥有了 "),s("code",[t._v("__proto__")]),t._v(" 属性。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个函数是 Function 的实例对象,function 内部调用了 new Function()")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("所以可以说，在 "),s("code",[t._v("new")]),t._v(" 的过程中，新对象被添加了 "),s("code",[t._v("__proto__")]),t._v(" 并且链接到构造函数的原型上。")]),t._v(" "),s("p",[t._v("创建对象的过程如下：")]),t._v(" "),s("ol",[s("li",[t._v("新生成了一个对象")]),t._v(" "),s("li",[t._v("链接到原型")]),t._v(" "),s("li",[t._v("绑定 this")]),t._v(" "),s("li",[t._v("返回新对象")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createObj")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个空对象")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获得构造函数")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" con "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("shift")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 链接到原型")]),t._v("\n  obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" con"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 绑定 this，执行构造函数")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("con")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 确保创建出来的是对象")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'object'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" obj\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("p",[t._v("对于实例对象来说，都是通过 "),s("code",[t._v("new")]),t._v(" 产生的，无论是 "),s("code",[t._v("function Foo()")]),t._v(" 还是 "),s("code",[t._v("let a = { b : 1 }")]),t._v("。")]),t._v(" "),s("p",[t._v("对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 "),s("code",[t._v("new Object()")]),t._v(" 的方式创建对象需要通过作用域链一层层找到 "),s("code",[t._v("Object")]),t._v("，但是你使用字面量的方式就没这个问题。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function 等同于 new Function()")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 字面量内部调用了 new Object()")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h2",{attrs:{id:"function-proto-function-prototype"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-proto-function-prototype"}},[t._v("#")]),t._v(" Function.proto === Function.prototype")]),t._v(" "),s("p",[t._v("对于对象来说，"),s("code",[t._v("obj.__proto__.contrcutor")]),t._v(" 是该对象的构造函数，但是在图中我们可以发现 "),s("code",[t._v("Function.__proto__ === Function.prototype")]),t._v("，难道这代表着 Function 自己产生了自己？答案肯定是否认的，要说明这个问题我们先从 "),s("code",[t._v("Object")]),t._v(" 说起。")]),t._v(" "),s("p",[t._v("从图中我们可以发现，所有对象都可以通过原型链最终找到 "),s("code",[t._v("Object.prototype")]),t._v(" ，虽然 "),s("code",[t._v("Object.prototype")]),t._v(" 也是一个对象，但是这个对象却不是 "),s("code",[t._v("Object")]),t._v(" 创造的，而是引擎自己创建了 "),s("code",[t._v("Object.prototype")]),t._v(" 。所以可以这样说，所有实例都是对象，但是对象不一定都是实例。")]),t._v(" "),s("p",[t._v("接下来我们来看 "),s("code",[t._v("Function.prototype")]),t._v(" 这个特殊的对象，如果你在浏览器将这个对象打印出来，会发现这个对象其实是一个函数。")]),t._v(" "),s("p",[t._v("我们知道函数都是通过 "),s("code",[t._v("new Function()")]),t._v(" 生成的，难道 "),s("code",[t._v("Function.prototype")]),t._v(" 也是通过 "),s("code",[t._v("new Function()")]),t._v(" 产生的吗？答案也是否定的，这个函数也是引擎自己创建的。首先引擎创建了 "),s("code",[t._v("Object.prototype")]),t._v(" ，然后创建了 "),s("code",[t._v("Function.prototype")]),t._v(" ，并且通过 "),s("code",[t._v("__proto__")]),t._v(" 将两者联系了起来。这里也很好的解释了上面的一个问题，为什么 "),s("code",[t._v("let fun = Function.prototype.bind()")]),t._v(" 没有 "),s("code",[t._v("prototype")]),t._v(" 属性。因为 "),s("code",[t._v("Function.prototype")]),t._v(" 是引擎创建出来的对象，引擎认为不需要给这个对象添加 "),s("code",[t._v("prototype")]),t._v(" 属性。")]),t._v(" "),s("p",[t._v("所以我们又可以得出一个结论，不是所有函数都是 "),s("code",[t._v("new Function()")]),t._v(" 产生的。")]),t._v(" "),s("p",[t._v("有了 "),s("code",[t._v("Function.prototype")]),t._v(" 以后才有了 "),s("code",[t._v("function Function()")]),t._v(" ，然后其他的构造函数都是 "),s("code",[t._v("function Function()")]),t._v(" 生成的。现在可以来解释 "),s("code",[t._v("Function.__proto__ === Function.prototype")]),t._v(" 这个问题了。因为先有的 "),s("code",[t._v("Function.prototype")]),t._v(" 以后才有的 "),s("code",[t._v("function Function()")]),t._v(" ，所以也就不存在鸡生蛋蛋生鸡的悖论问题了。对于为什么 "),s("code",[t._v("Function.__proto__")]),t._v(" 会等于 "),s("code",[t._v("Function.prototype")]),t._v(" ，个人的理解是：其他所有的构造函数都可以通过原型链找到 "),s("code",[t._v("Function.prototype")]),t._v(" ，并且 "),s("code",[t._v("function Function()")]),t._v(" 本质也是一个函数，为了不产生混乱就将 "),s("code",[t._v("function Function()")]),t._v(" 的 "),s("code",[t._v("__proto__")]),t._v(" 联系到了 "),s("code",[t._v("Function.prototype")]),t._v(" 上。")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("ul",[s("li",[t._v("Object 是所有对象的爸爸，所有对象都可以通过 "),s("code",[t._v("__proto__")]),t._v(" 找到它；")]),t._v(" "),s("li",[t._v("Function 是所有函数的爸爸，所有函数都可以通过 "),s("code",[t._v("__proto__")]),t._v(" 找到它；")]),t._v(" "),s("li",[t._v("Function.prototype 和 Object.prototype 是两个特殊的对象，它们由引擎来创建，其他对象都是通过构造器 "),s("code",[t._v("new")]),t._v(" 出来的；")]),t._v(" "),s("li",[t._v("函数的 "),s("code",[t._v("prototype")]),t._v(" 是一个对象，也就是原型，对象的 "),s("code",[t._v("__proto__")]),t._v(" 指向原型， "),s("code",[t._v("__proto__")]),t._v(" 将对象和原型连接起来组成了原型链；")])])])}),[],!1,null,null,null);n.default=a.exports}}]);