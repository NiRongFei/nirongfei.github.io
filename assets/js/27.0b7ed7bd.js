(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{381:function(v,_,e){"use strict";e.r(_);var t=e(0),i=Object(t.a)({},function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("浏览器的页面渲染机制一般分为以下几个步骤：")]),v._v(" "),e("ol",[e("li",[v._v("处理 HTML 并构建 DOM 树。")]),v._v(" "),e("li",[v._v("处理 CSS 构建 CSSOM 树。")]),v._v(" "),e("li",[v._v("将 DOM 与 CSSOM 合并成一个渲染树。")]),v._v(" "),e("li",[v._v("根据渲染树来布局，计算每个节点的位置。")]),v._v(" "),e("li",[v._v("调用 GPU 绘制，合成图层，显示在屏幕上。")])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043710.png",alt:"浏览器渲染"}})]),v._v(" "),e("p",[v._v("在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。")]),v._v(" "),e("p",[v._v("当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。")]),v._v(" "),e("h2",{attrs:{id:"页面加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页面加载","aria-hidden":"true"}},[v._v("#")]),v._v(" 页面加载")]),v._v(" "),e("p",[v._v("浏览器页面加载完成节点分为 DOMContentLoaded 和 Load 两种情况：")]),v._v(" "),e("ul",[e("li",[v._v("DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。")]),v._v(" "),e("li",[v._v("Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。")])]),v._v(" "),e("h2",{attrs:{id:"图层渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图层渲染","aria-hidden":"true"}},[v._v("#")]),v._v(" 图层渲染")]),v._v(" "),e("p",[v._v("一般来说，可以把普通文档流看成一个图层，特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。")]),v._v(" "),e("p",[v._v("通过以下几个常用属性可以生成新图层：")]),v._v(" "),e("ul",[e("li",[v._v("will-change")]),v._v(" "),e("li",[v._v("position: fixed")]),v._v(" "),e("li",[v._v("video、iframe 标签")]),v._v(" "),e("li",[v._v("通过动画实现的 opacity 转换")]),v._v(" "),e("li",[v._v("3D 变换：translate3d、translateZ")])]),v._v(" "),e("h2",{attrs:{id:"重绘-回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘-回流","aria-hidden":"true"}},[v._v("#")]),v._v(" 重绘/回流")]),v._v(" "),e("p",[v._v("重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。")]),v._v(" "),e("ul",[e("li",[v._v("重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘")]),v._v(" "),e("li",[v._v("回流是布局或者几何属性需要改变就称为回流。")])]),v._v(" "),e("p",[v._v("回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。")]),v._v(" "),e("p",[v._v("所以以下几个动作可能会导致性能问题：")]),v._v(" "),e("ul",[e("li",[v._v("盒模型")]),v._v(" "),e("li",[v._v("文字改变")]),v._v(" "),e("li",[v._v("字体改变")]),v._v(" "),e("li",[v._v("定位或者浮动")]),v._v(" "),e("li",[v._v("添加或删除样式")]),v._v(" "),e("li",[v._v("改变 window 大小")])]),v._v(" "),e("p",[v._v("很多人不知道的是，重绘和回流其实和 Event loop 有关。")]),v._v(" "),e("ol",[e("li",[v._v("当 Event loop 执行完 Microtasks 后，会判断 "),e("code",[v._v("document")]),v._v(" 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。")]),v._v(" "),e("li",[v._v("然后判断是否有 "),e("code",[v._v("resize")]),v._v(" 或者 "),e("code",[v._v("scroll")]),v._v(" ，有的话会去触发事件，所以 "),e("code",[v._v("resize")]),v._v(" 和 "),e("code",[v._v("scroll")]),v._v(" 事件也是至少 16ms 才会触发一次，并且自带节流功能。")]),v._v(" "),e("li",[v._v("判断是否触发了 "),e("code",[v._v("media query")])]),v._v(" "),e("li",[v._v("更新动画并且发送事件")]),v._v(" "),e("li",[v._v("判断是否有全屏操作事件")]),v._v(" "),e("li",[v._v("执行 "),e("code",[v._v("requestAnimationFrame")]),v._v(" 回调")]),v._v(" "),e("li",[v._v("执行 "),e("code",[v._v("IntersectionObserver")]),v._v(" 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好")]),v._v(" "),e("li",[v._v("更新界面")])]),v._v(" "),e("p",[v._v("以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 "),e("code",[v._v("requestIdleCallback")]),v._v(" 回调。")])])},[],!1,null,null,null);_.default=i.exports}}]);